## 폭발 이펙트 구현 설명 (기하 셰이더 기반)

### 1. 개요

- **목표:** 총알이 적과 충돌했을 때, 해당 위치에 스프라이트 시트(Sprite Sheet) 텍스처를 사용한 폭발 애니메이션을 빌보드(Billboard) 형태로 표시합니다.
- **핵심 전략:** CPU는 폭발의 '위치'와 '현재 프레임' 정보만 관리하고, 실제 사각형 생성과 UV 계산 등 복잡한 작업은 GPU의 **기하 셰이더(Geometry Shader)**가 담당하도록 하여 효율을 극대화합니다.

---

### 2. 구현 단계별 상세 설명

#### 1단계: 데이터 관리 - `CExplosionObject` 클래스

폭발 효과 하나를 표현하는 가벼운 오브젝트(`Object.h/cpp`)입니다.

- **역할**: 자신의 생명 주기(Life Cycle)와 현재 애니메이션 프레임을 스스로 관리합니다.
- **주요 멤버**:
  - `m_bIsAlive`: 폭발이 활성화 상태인지 여부.
  - `m_fAge`: 생성 후 경과 시간.
  - `m_nCurrentFrame`: 현재 재생 중인 애니메이션 프레임 번호 (0 ~ 63).
- **`Animate()` 함수**:
  1. 매 프레임 `m_fAge`를 누적합니다.
  2. `m_fAge`가 프레임당 재생 시간(`EXPLOSION_FRAME_TIME`)을 넘어서면, `m_nCurrentFrame`을 1 증가시키고 `m_fAge`를 초기화합니다.
  3. `m_nCurrentFrame`이 최대 프레임(`MAX_EXPLOSION_FRAME`)을 초과하면, 애니메이션이 끝난 것으로 간주하고 `m_bIsAlive`와 `m_bRender`를 `false`로 설정하여 스스로 비활성화됩니다.
- **셰이더로 데이터 전달**:
  - `Animate()` 함수에서 계산된 `m_nCurrentFrame` 값을, 이 오브젝트가 사용하는 `CMaterial`의 `m_nType` 멤버에 저장합니다.
  - 이 `m_nType` 값은 렌더링 시 `cbGameObjectInfo` 상수 버퍼의 `gnTexturesMask` 필드로 GPU에 전달됩니다. 셰이더는 이 값을 프레임 번호로 사용합니다.

#### 2단계: GPU 처리 - `CExplosionShader` 와 HLSL 코드

폭발 효과 렌더링만을 위한 전용 셰이더(`Shader.h/cpp`, `Shaders.hlsl`)입니다.

- **Vertex Shader (`VS_Explosion`)**:
  - CPU로부터 정점 1개(폭발 중심 월드 위치)를 입력받습니다.
  - 이 위치에 월드 변환을 적용하고, 상수 버퍼에서 프레임 번호를 읽어 **기하 셰이더로 그대로 전달**합니다.

- **Geometry Shader (`GS_Explosion`)**:
  - **이 구현의 핵심 파트입니다.**
  - VS에서 점 1개를 입력받아, 이를 중심으로 하는 **사각형(삼각형 2개로 구성된 Triangle Strip)을 실시간으로 생성**합니다.
  - 카메라의 `Right`와 `Up` 벡터(View 행렬에서 추출)를 사용하여 사각형이 항상 카메라를 바라보도록(빌보드) 만듭니다.
  - 생성된 4개의 꼭짓점에는 표준 UV 좌표 `(0,0), (1,0), (0,1), (1,1)`을 할당하여 Pixel Shader로 보냅니다.

- **Pixel Shader (`PS_Explosion`)**:
  - GS에서 보간된 UV 좌표와 프레임 번호를 입력받습니다.
  - 이 프레임 번호를 이용해 8x8 스프라이트 시트(`Image/Effect.dds`)에서 **현재 프레임에 해당하는 정확한 UV 영역을 계산**합니다.
    - 예: `frame = 9`일 경우, 2행 2열(u: 1/8, v: 1/8) 영역을 계산.
  - 최종 계산된 UV로 텍스처를 샘플링하여 픽셀 색상을 출력합니다.
  - `clip(color.a - 0.01f)`: 알파 테스팅을 통해 텍스처의 투명한 부분은 렌더링하지 않아, 사각형 테두리가 보이지 않고 자연스러운 폭발 모양만 그려지게 합니다.

- **Pipeline State Object (PSO) 설정**:
  - **블렌딩**: 가산 혼합(Additive Blending)을 사용하여 폭발이 주변과 어우러지며 밝게 빛나는 효과를 냅니다.
  - **깊이 버퍼**: 깊이 쓰기(Depth Write)를 비활성화하여, 반투명한 폭발 이펙트가 뒤에 있는 다른 오브젝트의 렌더링을 막지 않도록 합니다.
  - **기본 토폴로지**: `POINT`로 설정하여 정점 버퍼를 점들의 리스트로 해석하도록 합니다.

#### 3단계: 리소스 총괄 - `CScene` 클래스

씬에 필요한 모든 폭발 관련 리소스를 생성하고 관리합니다(`Scene.cpp`).

- **`BuildObjects()`**:
  - **공유 리소스 생성**: 모든 폭발 오브젝트가 함께 사용할 `CPointMesh`(점 1개), `CExplosionShader`, `CMaterial`(`Effect.dds` 텍스처 포함)을 단 한 번만 생성합니다.
  - **오브젝트 풀링 (Object Pooling)**: `std::vector<CExplosionObject*>`에 폭발 오브젝트를 미리 50개 생성해 둡니다. 이는 폭발이 필요할 때마다 `new`와 `delete`를 반복하며 발생하는 성능 저하를 막는 매우 효율적인 기법입니다.

- **`SpawnExplosion(position)`**:
  - 이 함수가 호출되면, 미리 만들어 둔 오브젝트 풀에서 다음 순번의 비활성 `CExplosionObject`를 가져와 `Start()` 함수를 호출하여 지정된 위치에 활성화시킵니다.

- **`AnimateExplosions()` / `RenderExplosions()`**:
  - 게임 루프의 `AnimateObjects`와 `Render`에서 각각 호출됩니다.
  - 활성화된(`IsAlive`, `m_bRender`) 폭발 오브젝트만 순회하며 애니메이션과 렌더링을 처리합니다.

#### 4단계: 실행 트리거 - `CheckBulletCollisions()`

- **역할**: 총알과 적의 충돌을 감지하고 폭발을 일으키는 기폭제 역할을 합니다.
- **로직**:
  1. 모든 활성화된 총알과 적들의 경계 상자(Bounding Box)를 비교하여 충돌을 검사합니다.
  2. 충돌이 감지되면, 적을 즉시 숨기는(`pEnemy->m_bRender = false`) 동시에 `SpawnExplosion(enemyPosition)`을 호출하여 적이 있던 바로 그 위치에 폭발 효과를 생성합니다.
  3. 사용된 총알은 `Kill()` 함수로 소멸시킵니다.
